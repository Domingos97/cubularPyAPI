# Pydantic schemas for API request/response models (DTOs)from pydantic import BaseModel, EmailStr, validator, Fieldfrom typing import Optional, List, Dict, Anyfrom datetime import datetimefrom enum import Enumimport uuid# Enums for APIclass UserRole(str, Enum):    USER = "user"    ADMIN = "admin"class MessageRole(str, Enum):    USER = "user"    ASSISTANT = "assistant"class NotificationType(str, Enum):    SURVEY_REQUEST = "survey_request"    FEATURE_REQUEST = "feature_request"    SUPPORT_REQUEST = "support_request"    FEEDBACK = "feedback"    OTHER = "other"class LogLevel(str, Enum):    DEBUG = "DEBUG"    INFO = "INFO"    WARNING = "WARNING"    ERROR = "ERROR"    CRITICAL = "CRITICAL"# Base schema for all Pydantic modelsclass BaseSchema(BaseModel):    class Config:        from_attributes = True        use_enum_values = True# User schemasclass UserBase(BaseSchema):    email: EmailStr    username: str    language: str = "en"class UserCreate(UserBase):    password: str = Field(..., min_length=6)class UserUpdate(BaseSchema):    username: Optional[str] = None    language: Optional[str] = None    preferred_personality_id: Optional[uuid.UUID] = None    welcome_popup_dismissed: Optional[bool] = Noneclass UserResponse(UserBase):    id: uuid.UUID    email_confirmed: bool    welcome_popup_dismissed: bool    last_login: Optional[datetime]    role: Optional[str] = None    created_at: datetime    updated_at: datetimeclass UserInDB(UserResponse):    password: str# Authentication schemasclass Token(BaseSchema):    access_token: str    refresh_token: str    token_type: str = "bearer"    expires_in: intclass TokenPayload(BaseSchema):    sub: Optional[str] = None    exp: Optional[int] = Noneclass RefreshTokenRequest(BaseSchema):    refresh_token: str# AI Personality schemasclass AIPersonalityBase(BaseSchema):    name: str    description: str    system_prompt: Optional[str] = None    detailed_analysis_prompt: Optional[str] = None    suggestions_prompt: Optional[str] = None    model_override: Optional[str] = None    temperature_override: Optional[float] = Noneclass AIPersonalityCreate(AIPersonalityBase):    passclass AIPersonalityUpdate(BaseSchema):    name: Optional[str] = None    description: Optional[str] = None    is_active: Optional[bool] = None    system_prompt: Optional[str] = None    detailed_analysis_prompt: Optional[str] = None    suggestions_prompt: Optional[str] = None    model_override: Optional[str] = None    temperature_override: Optional[float] = Noneclass AIPersonalityResponse(AIPersonalityBase):    id: uuid.UUID    is_active: bool    created_by: Optional[uuid.UUID]    created_at: datetime    updated_at: datetime# Survey schemasclass SurveyBase(BaseSchema):    title: str    description: Optional[str] = Noneclass SurveyCreate(SurveyBase):    passclass SurveyUpdate(BaseSchema):    title: Optional[str] = None    description: Optional[str] = None    is_active: Optional[bool] = Noneclass SurveyFileResponse(BaseSchema):    id: uuid.UUID    filename: str    original_filename: Optional[str]    file_size: Optional[int]    file_type: Optional[str]    upload_status: str    processing_status: str    total_responses: int    processed_responses: int    error_message: Optional[str]    created_at: datetimeclass SurveyResponse(SurveyBase):    id: uuid.UUID    is_active: bool    created_by: uuid.UUID    created_at: datetime    updated_at: datetime    files: List[SurveyFileResponse] = []# Alias for backward compatibilitySurvey = SurveyResponse# SurveyFile schema (alias for SurveyFileResponse)SurveyFile = SurveyFileResponse# Chat schemasclass ChatSessionBase(BaseSchema):    title: Optional[str] = "New Chat"class ChatSessionCreate(ChatSessionBase):    survey_ids: Optional[List[uuid.UUID]] = Noneclass ChatSessionUpdate(BaseSchema):    title: Optional[str] = None    is_active: Optional[bool] = None    selected_file_ids: Optional[List[uuid.UUID]] = Noneclass ChatMessageBase(BaseSchema):    content: str    role: MessageRole = MessageRole.USERclass ChatMessageCreate(ChatMessageBase):    metadata: Optional[Dict[str, Any]] = Noneclass ChatMessageResponse(ChatMessageBase):    id: uuid.UUID    session_id: uuid.UUID    metadata: Optional[Dict[str, Any]] = None    tokens_used: Optional[int] = None    created_at: datetimeclass ChatSessionResponse(ChatSessionBase):    id: uuid.UUID    user_id: uuid.UUID    is_active: bool    created_at: datetime    updated_at: datetime    selected_file_ids: List[uuid.UUID] = []    messages: List[ChatMessageResponse] = []    user_id: uuid.UUID    is_active: bool    created_at: datetime    updated_at: datetime    messages: List[ChatMessageResponse] = []# Search schemasclass SearchRequest(BaseSchema):    query: str    survey_ids: List[uuid.UUID]    threshold: float = Field(default=0.25, ge=0.0, le=1.0)    max_results: int = Field(default=1000, ge=1, le=10000)class SearchResult(BaseSchema):    survey_id: uuid.UUID    response_index: int    similarity: float    text: str    metadata: Dict[str, Any] = {}class SearchResponse(BaseSchema):    results: List[SearchResult]    total_found: int    search_params: Dict[str, Any]    query_embedding: Optional[List[float]] = None# Chat completion schemasclass ChatCompletionRequest(BaseSchema):    session_id: uuid.UUID    message: str    include_search: bool = True    search_params: Optional[SearchRequest] = Noneclass ChatCompletionResponse(BaseSchema):    message: ChatMessageResponse    search_results: Optional[SearchResponse] = None    ai_response: ChatMessageResponse# Notification schemasclass NotificationBase(BaseSchema):    type: NotificationType    title: str = Field(..., max_length=200)    message: str = Field(..., max_length=1000)    priority: int = Field(default=0, ge=0, le=10)class NotificationCreate(NotificationBase):    user_id: uuid.UUIDclass NotificationUpdate(BaseSchema):    is_read: Optional[bool] = None    read_at: Optional[datetime] = Noneclass NotificationResponse(NotificationBase):    id: uuid.UUID    user_id: uuid.UUID    is_read: bool    read_at: Optional[datetime]    created_at: datetime# File upload schemasclass FileUploadResponse(BaseSchema):    filename: str    file_size: int    upload_status: str    processing_status: str    message: str# Log schemasclass LogCreate(BaseSchema):    level: LogLevel    message: str    user_id: Optional[uuid.UUID] = None    endpoint: Optional[str] = None    method: Optional[str] = None    status_code: Optional[int] = None    response_time: Optional[int] = None    ip_address: Optional[str] = None    user_agent: Optional[str] = None    metadata: Optional[Dict[str, Any]] = Noneclass LogResponse(LogCreate):    id: uuid.UUID    created_at: datetime# Health check schemaclass HealthCheck(BaseSchema):    status: str    version: str    timestamp: datetime    database: str = "connected"    services: Dict[str, str] = {}# Error schemasclass ErrorResponse(BaseSchema):    detail: str    error_code: Optional[str] = None    timestamp: datetime = Field(default_factory=datetime.utcnow)class ValidationErrorResponse(BaseSchema):    detail: List[Dict[str, Any]]    error_code: str = "validation_error"    timestamp: datetime = Field(default_factory=datetime.utcnow)# Success schemasclass SuccessResponse(BaseSchema):    message: str    data: Optional[Dict[str, Any]] = None    timestamp: datetime = Field(default_factory=datetime.utcnow)# Module Configuration schemasclass ModuleConfigurationBase(BaseSchema):    module_name: str    model: str    temperature: Optional[float] = None    max_tokens: Optional[int] = None    max_completion_tokens: Optional[int] = Noneclass ModuleConfigurationCreate(ModuleConfigurationBase):    llm_setting_id: uuid.UUID    ai_personality_id: Optional[uuid.UUID] = Noneclass ModuleConfigurationUpdate(BaseSchema):    model: Optional[str] = None    temperature: Optional[float] = None    max_tokens: Optional[int] = None    max_completion_tokens: Optional[int] = None    active: Optional[bool] = None    ai_personality_id: Optional[uuid.UUID] = Noneclass ModuleConfigurationResponse(ModuleConfigurationBase):    id: uuid.UUID    llm_setting_id: uuid.UUID    active: bool    created_by: Optional[uuid.UUID]    ai_personality_id: Optional[uuid.UUID]    created_at: datetime    updated_at: datetime# Language schemasclass SupportedLanguageBase(BaseSchema):    code: str = Field(..., description="ISO 639-1 language code (e.g., 'en', 'es')")    name: str = Field(..., description="English name of the language")    native_name: str = Field(..., description="Native name of the language")    enabled: bool = True    is_rtl: bool = False    sort_order: int = 0class SupportedLanguageCreate(SupportedLanguageBase):    passclass SupportedLanguageUpdate(BaseSchema):    name: Optional[str] = None    native_name: Optional[str] = None    enabled: Optional[bool] = None    is_rtl: Optional[bool] = None    sort_order: Optional[int] = Noneclass SupportedLanguageResponse(SupportedLanguageBase):    id: uuid.UUID    created_at: datetime    updated_at: datetime# Prompt Translation schemasclass PromptTranslationBase(BaseSchema):    prompt_key: str = Field(..., description="Unique identifier for the prompt")    language_code: str = Field(..., description="Language code from supported_languages")    translated_text: str = Field(..., description="Translated text")    context: Optional[str] = Field(None, description="Context for translators")class PromptTranslationCreate(PromptTranslationBase):    passclass PromptTranslationUpdate(BaseSchema):    translated_text: Optional[str] = None    context: Optional[str] = Noneclass PromptTranslationResponse(PromptTranslationBase):    id: uuid.UUID    created_by: Optional[uuid.UUID]    created_at: datetime    updated_at: datetime# Language detection and config schemasclass LanguageDetectionResult(BaseSchema):    language: str = Field(..., description="Detected language code")    confidence: float = Field(..., description="Confidence score (0.0 to 1.0)")class LanguageConfigResponse(BaseSchema):    default_language: str    available_languages: List[str]    languages: List[SupportedLanguageResponse]class UserLanguagePreference(BaseSchema):    language_code: str = Field(..., description="User's preferred language code")# LLM Setting schemasclass LLMSettingBase(BaseSchema):    provider: strclass LLMSettingCreate(LLMSettingBase):    api_key: strclass LLMSettingUpdate(BaseSchema):    api_key: Optional[str] = None    active: Optional[bool] = Noneclass LLMSettingResponse(LLMSettingBase):    id: uuid.UUID    active: bool    api_key_configured: bool = True  # Don't expose actual API key    created_by: Optional[uuid.UUID]    created_at: datetime    updated_at: datetime# Vector Search schemasclass VectorSearchRequest(BaseSchema):    query: str    survey_ids: Optional[List[str]] = None    top_k: int = Field(default=10, ge=1, le=100)    similarity_threshold: float = Field(default=0.1, ge=0.0, le=1.0)class VectorSearchResponse(BaseSchema):    survey_id: str    file_id: str    text: str    similarity_score: float    metadata: Dict[str, Any]class SurveyInsightsRequest(BaseSchema):    analysis_type: str = "themes"class ThemeInsight(BaseSchema):    theme_id: int    size: int    percentage: float    representative_text: str    sample_texts: List[str]class InsightStatistics(BaseSchema):    avg_response_length: float    median_response_length: float    min_response_length: int    max_response_length: intclass SurveyInsightsResponse(BaseSchema):    total_responses: int    analysis_type: str    survey_id: str    themes: Optional[List[ThemeInsight]] = None    statistics: InsightStatistics# Survey Statistics schemasclass SurveyFileStats(BaseSchema):    id: uuid.UUID    filename: str    upload_status: str    processing_status: str    total_responses: Optional[int] = None    processed_responses: Optional[int] = None    error_message: Optional[str] = Noneclass SurveyStatistics(BaseSchema):    survey_id: uuid.UUID    title: str    created_at: datetime    total_files: int    total_responses: int    processed_responses: int    files: List[SurveyFileStats]# Access Control schemasclass AccessType(str, Enum):    READ = "read"    EDIT = "edit"     ADMIN = "admin"class UserSurveyAccessBase(BaseSchema):    user_id: uuid.UUID    survey_id: uuid.UUID    access_type: AccessTypeclass UserSurveyAccessCreate(BaseSchema):    user_id: uuid.UUID    access_type: AccessTypeclass UserSurveyAccessUpdate(BaseSchema):    access_type: Optional[AccessType] = Noneclass UserSurveyAccess(UserSurveyAccessBase):    id: uuid.UUID    created_at: datetime    updated_at: datetimeclass UserSurveyFileAccessBase(BaseSchema):    user_id: uuid.UUID    file_id: uuid.UUID    access_type: AccessTypeclass UserSurveyFileAccessCreate(BaseSchema):    user_id: uuid.UUID    access_type: AccessTypeclass UserSurveyFileAccessUpdate(BaseSchema):    access_type: Optional[AccessType] = Noneclass UserSurveyFileAccess(UserSurveyFileAccessBase):    id: uuid.UUID    created_at: datetime    updated_at: datetimeclass AccessGrant(BaseSchema):    user_id: uuid.UUID    access_type: AccessTypeclass BulkAccessGrant(BaseSchema):    access_grants: List[AccessGrant]# Plan schemasclass PlanBase(BaseSchema):    name: str    description: Optional[str] = None    price: Optional[float] = None    currency: str = "USD"    billing_cycle: Optional[str] = Noneclass PlanCreate(PlanBase):    features: Optional[str] = None  # JSON stringclass PlanUpdate(BaseSchema):    name: Optional[str] = None    description: Optional[str] = None    price: Optional[float] = None    currency: Optional[str] = None    billing_cycle: Optional[str] = None    features: Optional[str] = None    is_active: Optional[bool] = Noneclass Plan(PlanBase):    id: uuid.UUID    features: Optional[str] = None    is_active: bool    created_at: datetime    updated_at: datetimeclass UserPlanBase(BaseSchema):    user_id: uuid.UUID    plan_id: uuid.UUIDclass UserPlanCreate(UserPlanBase):    expires_at: Optional[datetime] = Noneclass UserPlan(UserPlanBase):    id: uuid.UUID    is_active: bool    started_at: datetime    expires_at: Optional[datetime]    created_at: datetime    updated_at: datetime# LLM Settings schemasclass LLMSettingBase(BaseSchema):    provider: strclass LLMSettingCreate(LLMSettingBase):    api_key: strclass LLMSettingUpdate(BaseSchema):    api_key: Optional[str] = None    active: Optional[bool] = Noneclass LLMSettingResponse(LLMSettingBase):    id: uuid.UUID    active: bool    api_key_configured: bool = True  # Don't expose actual API key    created_by: Optional[uuid.UUID]    created_at: datetime    updated_at: datetime# Module Configuration schemasclass ModuleConfigurationBase(BaseSchema):    module_name: str    model: str    temperature: Optional[float] = None    max_tokens: Optional[int] = None    max_completion_tokens: Optional[int] = Noneclass ModuleConfigurationCreate(ModuleConfigurationBase):    llm_setting_id: uuid.UUID    ai_personality_id: Optional[uuid.UUID] = Noneclass ModuleConfigurationUpdate(BaseSchema):    model: Optional[str] = None    temperature: Optional[float] = None    max_tokens: Optional[int] = None    max_completion_tokens: Optional[int] = None    active: Optional[bool] = None    ai_personality_id: Optional[uuid.UUID] = Noneclass ModuleConfigurationResponse(ModuleConfigurationBase):    id: uuid.UUID    llm_setting_id: uuid.UUID    active: bool    created_by: Optional[uuid.UUID]    ai_personality_id: Optional[uuid.UUID]    created_at: datetime    updated_at: datetime# Survey suggestion schemasclass SurveySuggestionBase(BaseSchema):    suggestion_text: str = Field(..., description="AI-generated suggestion text")    category: Optional[str] = Field(None, description="Suggestion category")    confidence_score: Optional[float] = Field(0.5, description="AI confidence score (0.0-1.0)")    language_code: str = "en"class SurveySuggestionCreate(SurveySuggestionBase):    survey_id: uuid.UUIDclass SurveySuggestionUpdate(BaseSchema):    suggestion_text: Optional[str] = None    category: Optional[str] = None    confidence_score: Optional[float] = None    is_active: Optional[bool] = Noneclass SurveySuggestionResponse(SurveySuggestionBase):    id: uuid.UUID    survey_id: uuid.UUID    ai_personality_id: Optional[uuid.UUID]    generated_by: Optional[uuid.UUID]    is_active: bool    created_at: datetime    updated_at: datetime# Survey analytics schemasclass SurveyAnalyticsBase(BaseSchema):    total_files: int = 0    total_file_size: int = 0    total_suggestions: int = 0    total_chat_sessions: int = 0    total_chat_messages: int = 0    analysis_status: str = "pending"class SurveyAnalyticsUpdate(BaseSchema):    total_files: Optional[int] = None    total_file_size: Optional[int] = None    total_suggestions: Optional[int] = None    total_chat_sessions: Optional[int] = None    total_chat_messages: Optional[int] = None    analysis_status: Optional[str] = None    metadata: Optional[str] = Noneclass SurveyAnalyticsResponse(SurveyAnalyticsBase):    id: uuid.UUID    survey_id: uuid.UUID    last_activity: Optional[datetime]    metadata: Optional[str]    created_at: datetime    updated_at: datetime# Enhanced chat schemasclass EnhancedChatSessionBase(BaseSchema):    session_name: Optional[str] = None    survey_ids: List[uuid.UUID] = Field(..., description="Array of survey IDs for RAG context")    personality_id: Optional[uuid.UUID] = None    language_code: str = "en"    context_metadata: Optional[str] = Noneclass EnhancedChatSessionCreate(EnhancedChatSessionBase):    passclass EnhancedChatSessionUpdate(BaseSchema):    session_name: Optional[str] = None    survey_ids: Optional[List[uuid.UUID]] = None    personality_id: Optional[uuid.UUID] = None    is_active: Optional[bool] = None    context_metadata: Optional[str] = Noneclass EnhancedChatSessionResponse(EnhancedChatSessionBase):    id: uuid.UUID    user_id: uuid.UUID    is_active: bool    created_at: datetime    updated_at: datetimeclass EnhancedChatMessageBase(BaseSchema):    role: str = Field(..., description="Message role: 'user' or 'assistant'")    content: str = Field(..., description="Message content")    search_results: Optional[str] = Field(None, description="JSON of RAG search results")    confidence_score: Optional[float] = None    processing_time: Optional[int] = None    tokens_used: Optional[int] = None    language_detected: Optional[str] = Noneclass EnhancedChatMessageCreate(EnhancedChatMessageBase):    session_id: uuid.UUIDclass EnhancedChatMessageResponse(EnhancedChatMessageBase):    id: uuid.UUID    session_id: uuid.UUID    created_at: datetime    updated_at: datetime# Request/Response schemas for survey suggestion generationclass GenerateSuggestionsRequest(BaseSchema):    survey_id: uuid.UUID    description: str = Field(..., description="Survey description for context")    category: str = Field("analysis", description="Suggestion category")    personality_id: Optional[uuid.UUID] = None    file_content: Optional[Dict[str, Any]] = Field(None, description="Optional file content for context")class GenerateSuggestionsResponse(BaseSchema):    suggestions: List[SurveySuggestionResponse]    generation_time: float    total_suggestions: int
 
 #   R o l e   s c h e m a s  
 c l a s s   R o l e B a s e ( B a s e S c h e m a ) :  
         r o l e :   s t r   =   F i e l d ( . . . ,   d e s c r i p t i o n = ' R o l e   n a m e ' ,   m a x _ l e n g t h = 2 5 5 )  
  
 c l a s s   R o l e C r e a t e ( R o l e B a s e ) :  
         p a s s  
  
 c l a s s   R o l e U p d a t e ( B a s e S c h e m a ) :  
         r o l e :   O p t i o n a l [ s t r ]   =   F i e l d ( N o n e ,   d e s c r i p t i o n = ' R o l e   n a m e ' ,   m a x _ l e n g t h = 2 5 5 )  
  
 c l a s s   R o l e R e s p o n s e ( R o l e B a s e ) :  
         i d :   u u i d . U U I D  
         c r e a t e d _ a t :   d a t e t i m e  
         u p d a t e d _ a t :   d a t e t i m e  
  
 c l a s s   R o l e S t a t i s t i c s ( B a s e S c h e m a ) :  
         t o t a l _ r o l e s :   i n t  
         t o t a l _ u s e r s :   i n t  
         r o l e _ u s a g e :   L i s t [ D i c t [ s t r ,   A n y ] ]  
  
 c l a s s   U s e r R o l e A s s i g n m e n t ( B a s e S c h e m a ) :  
         u s e r _ i d :   u u i d . U U I D  
         r o l e _ i d :   u u i d . U U I D  
  
 c l a s s   C h e c k U s e r R o l e R e s p o n s e ( B a s e S c h e m a ) :  
         h a s _ r o l e :   b o o l  
 